#lang racket
#|
the following code is for the UI to run according to user input,
(withthe exlusion of safe)
with safe being an expiriment to protect from user error.
|#
(define odds (lambda (n)
               (add1 (* 2 n))
               ))
(define even (lambda (n)
               (* 2 n)
               ))
(define fibo-acc (lambda (acc1 acc2 n)
                   (if
                    (equal? n 0)
                    (+ acc1 acc2)
                    (fibo-acc acc2 (+ acc1 acc2) (sub1 n))
                    )
                   ))
(define fibo (lambda (n)
                (fibo-acc 0 1 n)
                ))

(define series-acc (lambda(proc acc n)
                 (cond
                 [(equal? acc n) (writeln (number->string (proc acc)))]
                 [else
                 (begin
                 (writeln (number->string (proc acc)))(series-acc proc (add1 acc) n))
                 ]
                 )))
(define series (lambda (proc n)
                  (series-acc proc 1 (string->number n))
                  ))
#|
these are used by the UI to interpret
user commands
|#
(define exec-form/A (lambda (command expect proc)
                    (series proc (substring (symbol->string command) (add1 (string-length expect))))
                  ))
(define test-form (lambda (command expect)
                    (if
                    (not (or (number? command)(string? command)))
                    (if
                    (< (string-length (symbol->string command)) (+ 2 (string-length expect)))
                    #f
                    (equal? (substring (symbol->string command) 0 (string-length expect)) expect)
                    )
                    #f
                    )))
#|
the mode variable is how the old UI translates
the input into the code required to be run
and the help varible is text for the user to view,
with the "quit" and "xyzzy"
commands ideally cicrumenting the mode variable
|#
(define mode "none")
(define last "none")
(define help "
This program be can set to different calculation modes using simple commands,                                    
the commands Fibo/Fibonacci/F set the mode to calculate fibonacci numbers,                                       
the commands Odds/Odd numbers/O set the mode to calculate Odd numbers.                                           
once in these modes select a number for the program to use."
)
#|
this is the old version of the UI, archived for comparision to the current code,
[modified so it can be 3mu1at3d by the current UI]
|#
(define interface/0 (lambda ()
                    (writeln ">:")
                    (let ((input (read)))
                      (if (not (equal? input 'quit))
                      (begin
                      (if         (equal? mode "none")
                               (cond
                                 [(equal? input ''Fibonacci)(set! mode "fibo")]
                                 [(equal? input 'Fibo)(set! mode "fibo")]
                                 [(equal? input 'F)(set! mode "fibo")]
                                 [(equal? input 'Odds)(set! mode "odds")]
                                 [(equal? input 'O)(set! mode "odds")]
                                 [(equal? input 'help)(begin (writeln help) (interface/2))]
                                 [else (writeln "command not reconnized.")]
                                 )
                                 (cond
                                   [(equal? mode "fibo")(begin (series fibo input) (set! mode "none"))]
                                   [(equal? mode "odds")(begin (series odds input) (set! mode "none"))]
                                   [else (writeln "deep error(ie, a fluke),please restart program.")]
                                   )
                              )
                      (interface/0)
                      )
                      (begin (writeln "emulator exited.") (interface/2))
                      )
                    )))
#|
if you want add a special command then insert into interface/2,
and if it's really complicated then aux it,
[the term special command means a rigid function of no inputs [for trolling the user]]
[contrasted with normal commands, which have inputs for their calculations]
with normal commands defined by docalc,
using test form to interpret the prefix.
|#
(define help-new
"fibo odds even retro noss"
)
(define help-fun (lambda (input)
                     (cond
                       [(test-form input "fibo") (writeln "fibonnachi function:          [math]")]
                       [(test-form input "odds") (writeln "list all odd numbers:         [math]")]
                       [(test-form input "even") (writeln "list all even numbers:        [math]")]
                       [(test-form input "retro") (writeln "shows last command used:   [devtool]")]
                       [(test-form input "noss") (writeln "emulation of old version:  [devtool]")]
                       )
                   ))
(define xyzzy (lambda ()
                (begin
                  (writeln "last command used:")
                  (writeln last)
                  (set! last "retrocognition")
                  (interface/2)
              )))
(define cogder (lambda ()
                 (begin
                   (writeln "entering emulator")
                   (set! last "nostalgia")
                   (interface/0)
               )))
(define docalc (lambda (input)
                 (cond
                   [(test-form input "fibo")(begin (exec-form/A input "fibo" fibo)(set! last "math;fibo"))]
                   [(test-form input "odds")(begin (exec-form/A input "odds" odds)(set! last "math;odds"))]
                   [(test-form input "even")(begin (exec-form/A input "even" even)(set! last "math;even"))]
                   [(test-form input "backdoor")(writeln (string-append "what sort of moron has '" (substring (symbol->string input) 9) "' as his password?"))]
                   [(test-form input "help")(begin (help-fun input) (interface/2))]
                   [else (writeln "not a command")]
                 )))
(define interface/2 (lambda ()
                    (writeln ">:")
                    (let ((input (read)))
                      (cond
                      [(equal? input 'quit)(writeln "program terminated.")]
                      [(equal? input 'xyzzy)(xyzzy)]
                      [(equal? input 'cogder)(cogder)]
                      [(equal? input 'backdoor)(writeln "never gonna give you up, never gonna let you down")]
                      [(equal? input 'help)(begin (writeln help-new) (interface/2))]
                      [else
                      (begin
                      (docalc input)
                      (interface/2))
                      ]
                      ))))
;;now this runs the code
(writeln "SERIUSCALC program, type 'help' for more information, type 'quit' to exit the program")
(interface/2)